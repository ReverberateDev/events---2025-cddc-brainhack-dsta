from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import binascii

def hex_to_binary_string(hex_string):
    """Converts a hex string to a binary string (0s and 1s)."""
    return bin(int(hex_string, 16))[2:].zfill(len(hex_string) * 4)

def binary_string_to_bytes(bin_str):
    """Converts a binary string (0s and 1s) to a byte string."""
    if not bin_str: # Handle empty binary string
        return b''
    return int(bin_str, 2).to_bytes((len(bin_str) + 7) // 8, byteorder='big')

# --- Input Data ---
leaked_alice_bits_str = "0XXXX000XX010XXXX0XX1011X11XX0110X1X1XXXXXX111011XX11XX1X1X1X0010X1111X0X110XXX1X11001001X10X1001XXXXXX0XXXXXXX01X1X110000X10X11XX0101XX010XXX1XXXX0XXX0X01XX1X10XX110XX111XXXX0X1XX0X0X010X01XXX1X1X0X0XXXXX00X1XXX10X111XX110X01XXXXX00X011100X0101XX1XXXX0001"

# The successful exchange bases
alice_bases_final_hex = "c660266d7f3173174f11f033b5c101e1156127204461ab60674f1d97f31f3121"
bob_bases_final_hex   = "c6730d86456cac46337494df47a1bdd6c2364f1f7e857e273f57a64aab0398d0"

# Ciphertext parts (ensure this list is complete and in order)
ciphertext_hex_parts = [
    "6adec6eeae8bcf69bdba1b05827d63f3c6d062a18cb168c2e2be215a814e375df28ab12da0bac48f958b9f361e014bb993af3ce34746e1c2ffc5ec9c4c140c99",
    "8c2ee854021e9ebbd13f5268b358b0bd713b0ab704a10f8c4a2c4d0dfb9ff7b0",
    "9c39304a0e80a3f529a616f495e5f92d0485a3b417b494721eb0284fe142f98a",
    "938a0769aa9e81303c45ddd904005232db0a3f700c4e08a5b1b400a6e628045c162e5e571d73931752b81fc62e40065fdd8f21528c4a26fa58b7a7cd66c1aaf7bc0dd7bbfe794996c9c0848d143d364cd81d9f49eccd5a131557528852bb7811cd2a679614bc0b7a19e0a9f419fb27e31fee7dc4f1e34d905667c3310f00f2f091c4b39979fe53cd3b04b290cf1b3b159659f79411eb8f6e3a145265e75cacd19457764963ffd52702880115b07373eee1afc2a1ca6d11694f5e48c24512c6ffb17c3bb60d6f4f3510742176b89b31a8db9d3103222f585cd245e4f15ec1aa3b64a471958798ad2fbcef6cf9ab458073baecba8b78b585663f17f4ca9087a4a7e70d417dfffa2d7eba1b6bcf1ddcc2d093aea3a2d7c2692394588094ddf75822db2860a1d89929ac82ffa28b67d81b2d7d28e6d65cf80b9a041576e5ae0ecbb8e01d5ec9ca464c039564a8ee81f530d606cc346a3595ce01107e36d8d9692558489300d49d0277332bc68dbe29c5d726afb67402af38de9f5ebc432f62a064f6f0264f5743455ee4a85f456c47362d3645940a174abccbe3019837352b4124ace00b4caec6999afba2c3f30c0bd67f258726e47335125b0a450fc3b8ca1da8f108826d4ef797aa0a543716d0d61f5f4ccebedf9217ad917d84c24e05f5db352304ef5855d047eeb951e61922f8bc8e795f0d250e6bf3a4c1c739d016a098a81a6872099f9b6d4093514c13eb89b22b3a37db1316516eddc7a882c5a1f62951280c86b60beff1a7182868ae6722e9d6ddbde8bcc1eb5a04669b727a1188064b1cc8a5856b5365efb1dc1173a6f3cabef7863693a31a903929d0918faf08a208e6b147e1fd362c31bf75cdc8f1cb3841b42e375c839f065a26a5c689092e7e3ae65e1a3087b3af8240ab2e4aa5f4ba0c3028e1c146991f6048ebefcfb04a572bd889c9ebcec3e80445b4d19e686ef2765c14a4506ea7268927a99afb0b48383cd7c4ea7df83446377204a0805c837216a25613a25a2213bd6019dfa034d846ef3e2c17c423392d4e065a885a9e7ab44a3e6cae3c070fd152ae9bd63a7a886c8719c97a09feaef18739aea4e3eef8a0b259c64c413d0b5114eaf7e0be26590932384b8085152fad039f5acde23dbb4fa9406d8475a81272208e9aa18f9d6571f2b2d0b52f7b73df8eba87d3f8cff966c0c5aaa55fbd0c30cc24a035fa15c1e56ed5cbb9dc0c6bbe50ce697b58da0d05349489e853976dc17d484e7bb6250a7e1895690fae6f07f74b4ce793d56e063b89cafe30e729543c4e6656df750640ceb8e6afafa8cad54069a4f037973668efa3263b2cb4b8f124fb898b309549bfc574e23354e11102856c64293823bf6ec39731588cfd64c3c8f585d62426388521105bc58dda0aa8159c62dfc6285ce67e8b925d6cba1202299167974739ed5e987e50e52209a9162084a21d7104b343a07f3454a74537a4b90826e78d8eab9e7a14bf",
    "763b8033fe834a66f2370ff9e1219a9b8b906206f21ba98f4e7c082b30482b6d"
]
full_ciphertext_payload_hex = "".join(ciphertext_hex_parts)

# --- BB84 Key Derivation ---
alice_bases_bin = hex_to_binary_string(alice_bases_final_hex)
bob_bases_bin = hex_to_binary_string(bob_bases_final_hex)

if len(alice_bases_bin) != 256 or len(bob_bases_bin) != 256 or len(leaked_alice_bits_str) != 256:
    print("Error: Length mismatch in input strings for BB84 key derivation!")
    exit()

sifted_key_bits = []
print("\nSifting Process Details (only showing bits that form the key):")
print("-------------------------------------------------------------------------------")
print("Idx | Alice's Bit | Alice's Base | Bob's Base | Bases Match? | Bit Known? | Key Bit")
print("-------------------------------------------------------------------------------")

for i in range(256):
    alice_original_bit = leaked_alice_bits_str[i]
    alice_base = alice_bases_bin[i]
    bob_base = bob_bases_bin[i]
    bases_match = (alice_base == bob_base)
    bit_known = (alice_original_bit != 'X')
    if bases_match and bit_known:
        sifted_key_bits.append(alice_original_bit)
        key_bit_to_add = alice_original_bit
        print(f"{str(i):>3s} | {str(alice_original_bit):^11s} | {str(alice_base):^12s} | {str(bob_base):^10s} | {str(bases_match):^12s} | {str(bit_known):^10s} | {str(key_bit_to_add)}")
sifted_key_str = "".join(sifted_key_bits)
print("-------------------------------------------------------------------------------")
print(f"Sifted key (before removing verification bits): {sifted_key_str}")
print(f"Length of sifted key (before removal): {len(sifted_key_str)}")

if len(sifted_key_str) < 8:
    print("Error: Sifted key is too short to remove 8 verification bits.")
    final_session_key_str = sifted_key_str
else:
    final_session_key_str = sifted_key_str[8:]

print(f"Final BB84 session key (binary string): {final_session_key_str}")
print(f"Length of BB84 session key (bits): {len(final_session_key_str)}")

if not final_session_key_str:
    print("Error: Final BB84 session key is empty. Cannot proceed with AES.")
    exit()

bb84_key_bytes = binary_string_to_bytes(final_session_key_str)

# --- AES Decryption ---
derived_aes_key = None
aes_key_lengths_bytes = [16, 24, 32] # AES-128, AES-192, AES-256

# Attempt to use the BB84 key, appropriately padded or truncated
if len(bb84_key_bytes) == 0 and len(final_session_key_str) > 0 : # Should not happen if final_session_key_str not empty
    print("Error: bb84_key_bytes is empty despite final_session_key_str having content. This is a bug.")
    exit()
    
if len(bb84_key_bytes) > 0 :
    if len(bb84_key_bytes) >= 32: # Enough for AES-256
        derived_aes_key = bb84_key_bytes[:32]
    elif len(bb84_key_bytes) >= 24: # Enough for AES-192
        derived_aes_key = bb84_key_bytes[:24]
    elif len(bb84_key_bytes) >= 16: # Enough for AES-128
        derived_aes_key = bb84_key_bytes[:16]
    else: # Too short, pad to 16 bytes (AES-128)
        derived_aes_key = bb84_key_bytes.ljust(16, b'\0')
else: # If bb84_key_bytes is empty (e.g. final_session_key_str was empty)
    print("BB84 key is empty, attempting AES with a default test key (e.g. 16 null bytes) for structure testing.")
    # This case is mainly for allowing the script to run further if key derivation failed completely.
    # The actual key would be wrong.
    derived_aes_key = b'\0' * 16


print(f"Using AES key (hex): {derived_aes_key.hex()} (Length: {len(derived_aes_key)} bytes)")

full_ciphertext_bytes = binascii.unhexlify(full_ciphertext_payload_hex)
iv_length = 16 
if len(full_ciphertext_bytes) < iv_length:
    print("Error: Ciphertext is too short to contain an IV.")
    exit()

iv = full_ciphertext_bytes[:iv_length]
actual_ciphertext = full_ciphertext_bytes[iv_length:]

print(f"IV (hex): {iv.hex()}")
print(f"Actual Ciphertext for AES (length bytes): {len(actual_ciphertext)}")

if not actual_ciphertext:
    print("Error: No actual ciphertext remaining after IV extraction.")
    exit()
if len(actual_ciphertext) % AES.block_size != 0:
    print(f"Warning: Actual ciphertext length ({len(actual_ciphertext)}) is not a multiple of AES block size ({AES.block_size}). Decryption might be partial or unpadding might fail.")

try:
    cipher = AES.new(derived_aes_key, AES.MODE_CBC, iv)
    decrypted_padded_bytes = cipher.decrypt(actual_ciphertext)
    decrypted_bytes = unpad(decrypted_padded_bytes, AES.block_size)
    
    decrypted_text = ""
    try:
        decrypted_text = decrypted_bytes.decode('utf-8')
        print(f"\nDecrypted Text (UTF-8):\n{decrypted_text}")
    except UnicodeDecodeError:
        try:
            decrypted_text = decrypted_bytes.decode('latin-1')
            print(f"\nDecrypted Text (Latin-1):\n{decrypted_text}")
        except Exception as decode_err:
            print(f"\nCould not decode decrypted bytes as text (UTF-8 or Latin-1): {decode_err}")
            print(f"Decrypted Bytes (hex): {decrypted_bytes.hex()}")
    
    if decrypted_text:
        print(f"\nFlag: CDDC2025{{{decrypted_text.strip()}}}")

except ValueError as e:
    print(f"\nAES Decryption or Unpadding Error: {e}")
except Exception as e:
    print(f"\nAn unexpected error occurred during AES decryption: {e}")