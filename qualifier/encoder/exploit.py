import base64

def solve_cipher():
    encoded_string = "MEi4xJpC4pI+FiJuAn4i2o7hpfHVCavRpfkzp18rX99jwWdodAA0wHQAYtKO9noGdBJ2sg=="
    
    try:
        decoded_b64_bytes = base64.b64decode(encoded_string)
    except Exception as e:
        print(f"Error decoding Base64 string: {e}")
        return

    print(f"Length of Base64 decoded data: {len(decoded_b64_bytes)} bytes")
    print("--- Attempting Additive Cipher (Byte Shift) ---")
    for key_offset in range(256):
        # This key_offset is the value that was *added* during encoding.
        # So, for decoding, we subtract it.
        temp_bytes = bytearray(len(decoded_b64_bytes))
        for i, byte_val in enumerate(decoded_b64_bytes):
            temp_bytes[i] = (byte_val - key_offset + 256) % 256
        
        try:
            recovered_string = temp_bytes.decode('utf-8')
            # Heuristic: Check for printable characters and some structure
            # Flags are often printable ASCII.
            is_mostly_printable_ascii = all(32 <= b < 127 or b in (9, 10, 13) for b in temp_bytes) # space to ~, tab, lf, cr
            
            if is_mostly_printable_ascii and len(recovered_string) > 5: # Arbitrary minimum length
                 # Look for common flag characteristics or keywords
                if ("_" in recovered_string or any(kw in recovered_string.lower() for kw in ["flag", "key", "cddc", "elixir", "beam"])):
                    print(f"[+] Additive Key (value added during encoding): {key_offset}")
                    print(f"    Decoded String: {recovered_string}\n")
        except UnicodeDecodeError:
            continue # Not valid UTF-8, skip
        except Exception as e:
            # print(f"Unexpected error with additive key {key_offset}: {e}")
            continue

    print("\n--- Attempting XOR Cipher ---")
    for xor_key in range(1, 256): # XOR with 0 is identity, so skip it
        temp_bytes = bytearray(len(decoded_b64_bytes))
        for i, byte_val in enumerate(decoded_b64_bytes):
            temp_bytes[i] = byte_val ^ xor_key
            
        try:
            recovered_string = temp_bytes.decode('utf-8')
            is_mostly_printable_ascii = all(32 <= b < 127 or b in (9, 10, 13) for b in temp_bytes)

            if is_mostly_printable_ascii and len(recovered_string) > 5:
                if ("_" in recovered_string or any(kw in recovered_string.lower() for kw in ["flag", "key", "cddc", "elixir", "beam"])):
                    print(f"[+] XOR Key: {xor_key}")
                    print(f"    Decoded String: {recovered_string}\n")
        except UnicodeDecodeError:
            continue
        except Exception as e:
            # print(f"Unexpected error with XOR key {xor_key}: {e}")
            continue

if __name__ == '__main__':
    solve_cipher()