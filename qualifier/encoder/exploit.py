import base64

# Helper function to reverse bits of a byte
# This is equivalent to the Elixir reverse_bits function
def reverse_bits(byte_val):
    result = 0
    for i in range(8):
        if (byte_val & (1 << i)): # Check if the i-th bit (from right) is set
            result |= (1 << (7 - i)) # Set the (7-i)-th bit in the result
    return result

def decode_string(base64_encoded_string):
    # Step 0: Base64 decode the input string
    try:
        data_binary = base64.b64decode(base64_encoded_string)
    except Exception as e:
        return f"Error: Invalid Base64 string - {e}"

    original_char_codes = []
    base_key = 66

    for index, encoded_byte in enumerate(data_binary):
        # Step 1: Reverse reverse_bits
        xored2_recovered = reverse_bits(encoded_byte)

        # Step 2: Calculate position_key (same as in encoding)
        position_key = ((index * 7) + 13) % 256

        # Step 3: Reverse XOR with position_key
        xored1_recovered = xored2_recovered ^ position_key

        # Step 4: Reverse XOR with base_key
        original_char_code = xored1_recovered ^ base_key

        original_char_codes.append(original_char_code)

    # Convert list of char codes back to a string
    # bytes() constructor takes a list of integers (0-255) and creates a bytes object
    # .decode('utf-8', errors='ignore') converts bytes to string
    try:
        decoded_plaintext = bytes(original_char_codes).decode('utf-8')
    except UnicodeDecodeError:
        # If it's not valid UTF-8, maybe it's just ASCII or another encoding
        # For CTFs, often simple ASCII or latin-1 is enough if UTF-8 fails
        try:
            decoded_plaintext = bytes(original_char_codes).decode('latin-1')
        except Exception as e:
            return f"Error decoding bytes to string: {e}. Raw bytes: {original_char_codes}"

    return decoded_plaintext

# The encoded string from the problem
encoded_str = "MEi4xJpC4pI+FiJuAn4i2o7hpfHVCavRpfkzp18rX99jwWdodAA0wHQAYtKO9noGdBJ2sg=="

print(f"Decoding: {encoded_str}")
decoded_plaintext = decode_string(encoded_str)
print(f"Decoded Plaintext: {decoded_plaintext}")

# Format the flag
if "Error:" not in decoded_plaintext:
    print(f"Flag: CDDC2025{{{decoded_plaintext}}}")
else:
    print("Could not generate flag due to decoding error.")