import os
import sqlite3
import traceback

def dump_table_data(cursor, table_name, output_file):
    """Dumps schema and all rows from a specific table."""
    try:
        output_file.write(f"\n--- Schema for table: {table_name} ---\n")
        cursor.execute(f"SELECT sql FROM sqlite_master WHERE type='table' AND name='{table_name}';")
        schema_rows = cursor.fetchall()
        for schema_row in schema_rows:
            if schema_row[0]: # sql column might be None for some system tables
                 output_file.write(schema_row[0] + "\n")

        output_file.write(f"\n--- Data for table: {table_name} ---\n")
        cursor.execute(f"SELECT * FROM {table_name};")
        rows = cursor.fetchall()
        if rows:
            # Get column names for header (optional, but good for readability)
            column_names = [description[0] for description in cursor.description]
            output_file.write("\t".join(column_names) + "\n") # TSV header
            for row_num, row in enumerate(rows):
                # Convert all cell values to strings to handle various data types (especially None)
                # Replace None with 'NULL' string for clarity
                # Replace newlines and tabs within data to keep TSV format clean
                cleaned_row = [str(cell).replace('\n', '\\n').replace('\t', '\\t') if cell is not None else 'NULL' for cell in row]
                output_file.write("\t".join(cleaned_row) + "\n")
                if row_num >= 199: # Limit rows per table to avoid excessively large files per table
                    output_file.write(f"... (and more rows, limited to 200 for brevity)\n")
                    break
        else:
            output_file.write("(No data in this table)\n")
        output_file.write("-" * 50 + "\n")

    except sqlite3.Error as e:
        output_file.write(f"SQLite error processing table {table_name}: {e}\n")
    except Exception as e:
        output_file.write(f"Generic error processing table {table_name}: {e}\n")
        output_file.write(traceback.format_exc() + "\n")


def process_database(db_path, output_file_path):
    """Processes a single SQLite database file."""
    print(f"Processing database: {db_path}")
    with open(output_file_path, 'a', encoding='utf-8', errors='replace') as outfile:
        outfile.write(f"\n\n{'='*20} DATABASE: {db_path} {'='*20}\n")
        try:
            conn = sqlite3.connect(f'file:{db_path}?mode=ro', uri=True) # Open in read-only mode
            cursor = conn.cursor()

            # Get list of tables
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            tables = cursor.fetchall()
            if not tables:
                outfile.write("No tables found in this database.\n")
                conn.close()
                return

            outfile.write("\nTables found:\n")
            for table_row in tables:
                outfile.write(f"- {table_row[0]}\n")

            for table_row in tables:
                table_name = table_row[0]
                # Avoid very common system tables that are unlikely to hold user data directly for this pass
                if table_name in ['android_metadata', 'sqlite_sequence', 'room_master_table']:
                    continue
                dump_table_data(cursor, table_name, outfile)

            conn.close()
        except sqlite3.Error as e:
            outfile.write(f"Error connecting to or processing database {db_path}: {e}\n")
            if "file is not a database" in str(e) or "database disk image is malformed" in str(e):
                 outfile.write(f"Skipping {db_path} as it's not a valid SQLite file or is corrupted.\n")
            else:
                 outfile.write(traceback.format_exc() + "\n")
        except Exception as e:
            outfile.write(f"Unexpected error with database {db_path}: {e}\n")
            outfile.write(traceback.format_exc() + "\n")


def main():
    data_folder = 'data'  # Assuming the script is run from the directory containing 'data'
    output_dump_file = 'all_db_content_dump.txt'

    # Clear the output file if it exists
    if os.path.exists(output_dump_file):
        os.remove(output_dump_file)

    db_files_found = 0
    for root, _, files in os.walk(data_folder):
        for file_name in files:
            if file_name.lower().endswith(('.db', '.sqlite', '.sqlite3')):
                db_path = os.path.join(root, file_name)
                # Skip journal files, wal files, shm files
                if any(ext in file_name.lower() for ext in ['-journal', '-wal', '-shm']):
                    continue
                process_database(db_path, output_dump_file)
                db_files_found +=1
    
    print(f"\nProcessed {db_files_found} potential database files.")
    print(f"Output dumped to: {output_dump_file}")

if __name__ == '__main__':
    main()